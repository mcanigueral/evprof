knitr::kable(digits = 2, col.names = c(
"Cluster", "Controid Start time", "Centroid Connection hours", "Interpretation", "Profile"
))
# Join the classification of each subset
sessions_profiles <- set_profiles(
sessions_clustered = list(workday_GMM$sessions, weekend_GMM$sessions),
clusters_definition = list(workday_clusters_profiles, weekend_clusters_profiles)
)
head(sessions_profiles)
classification_profiles_plot <- plot_points(sessions_profiles, start = 3, log = FALSE, aes(color = Profile), size = 0.3) +
facet_wrap(~ Timecycle)
classification_profiles_plot
ggsave(
filename = 'california_data/figures/CLUSTERS/classification_profiles.pdf', plot = classification_profiles_plot, paper="a4r", width = 40, height = 10
)
classification_clusters_plot <- plot_points(sessions_profiles, start = 6, log = FALSE, aes(color = Cluster), size = 0.3) +
facet_wrap(~ Timecycle)
ggsave(
filename = 'california_data/figures/CLUSTERS/classification_clusters.pdf', plot = classification_clusters_plot, paper="a4r", width = 40, height = 10
)
save(workday_clusters_profiles, weekend_clusters_profiles, sessions_profiles, file = 'california_data/california_sessions_profiles.RData')
saveRDS(sessions_profiles, "californa_sessions_profiles.RDS")
# Build the models
workday_connection_models <- get_connection_models(list(workday_GMM), list(workday_clusters_profiles))
# Plot the bivariate GMM
workday_connection_models_plot <- plot_model_clusters(list(workday_GMM), list(workday_clusters_profiles), workday_connection_models[c("profile", "ratio")])
workday_connection_models_plot
# Save the result
ggsave(
filename = 'california_data/figures/MODELS/connection_workday_GMM.pdf',
plot = workday_connection_models_plot,
paper="a4r", width = 40, height = 20
)
# Build the models
workday_energy_models <- sessions_profiles %>%
filter(Timecycle == 'Workday') %>%
get_energy_models(
log = TRUE,
by_power = FALSE
)
# Plot the univariate GMM
workday_energy_models_plots <- plot_energy_models(workday_energy_models)
workday_energy_models_plots
# Save the result
ggsave(
filename = 'california_data/figures/MODELS/energy_workday_GMM.pdf',
plot = workday_energy_models_plots,
paper="a4r", width = 40, height = 20
)
# Build the models
weekend_connection_models <- get_connection_models(list(weekend_GMM), list(weekend_clusters_profiles))
# Plot the bivariate GMM
weekend_connection_models_plot <- plot_model_clusters(list(weekend_GMM), list(weekend_clusters_profiles), weekend_connection_models[c("profile", "ratio")])
weekend_connection_models_plot
# Save the result
ggsave(
filename = 'california_data/figures/MODELS/connection_weekend_GMM.pdf',
plot = weekend_connection_models_plot,
paper="a4r", width = 40, height = 20
)
# Build the models
weekend_energy_models <- sessions_profiles %>%
filter(Timecycle == 'Weekend') %>%
get_energy_models(
log = TRUE,
by_power = FALSE
)
# Plot the univariate GMM
weekend_energy_models_plot <- plot_energy_models(weekend_energy_models, nrow = 1)
weekend_energy_models_plot
# Save the result
ggsave(
filename = 'california_data/figures/MODELS/energy_weekend_GMM.pdf',
plot = weekend_energy_models_plot,
paper="a4r", width = 40, height = 20
)
ev_model <- get_ev_model(
names = c('Workday', 'Weekend'),
months_lst = list(1:12),
wdays_lst = list(1:5, 6:7),
connection_GMM = list(workday_connection_models, weekend_connection_models),
energy_GMM = list(workday_energy_models, weekend_energy_models),
connection_log = T,
energy_log = T
)
ev_model
save_ev_model(ev_model, 'california_data/california_evmodel.json')
save(
workday_connection_models, workday_energy_models, weekend_connection_models, weekend_energy_models, ev_model,
file = 'california_data/california_sessions_models.RData'
)
library(dygraphs)
library(lubridate)
library(evsim)
library(dutils)
interval_mins <- 15
start_date <- dmy_hm(010920190000, tz = getOption('evprof.tzone')) + days(1)
end_date <-  dmy_hm(300920190000, tz = getOption('evprof.tzone')) + days(1)
dttm_seq <- seq.POSIXt(from = start_date, to = end_date, by = paste(interval_mins, 'min'))
sessions_demand <- sessions_profiles %>%
filter(between(ConnectionStartDateTime, start_date, end_date))
demand <- sessions_demand %>%
get_demand(dttm_seq)
demand %>% dyplot(fillGraph = T)
charging_rates <- get_charging_rates_distribution(sessions_demand) %>%
select(power, ratio)
print(charging_rates)
demand %>% dyplot(fillGraph = T)
charging_rates <- get_charging_rates_distribution(sessions_demand) %>%
select(power, ratio)
print(charging_rates)
n_sessions <- sessions_demand %>%
group_by(Timecycle) %>%
summarise(n = n()) %>%
mutate(n_day = round(n/c(20, 8))) %>% # Divided by the monthly days of each time-cycle
select(time_cycle = Timecycle, n_sessions = n_day)
print(n_sessions)
profiles_ratios <- sessions_demand %>%
group_by(Timecycle, Profile) %>%
summarise(n = n()) %>%
mutate(ratio = n/sum(n)) %>%
select(time_cycle = Timecycle, profile = Profile, ratio) %>%
ungroup()
print(profiles_ratios)
sessions_estimated <- simulate_sessions(
evmodel = ev_model,
sessions_day = n_sessions,
user_profiles = profiles_ratios,
charging_powers = charging_rates,
dates = unique(date(dttm_seq)),
resolution = interval_mins
)
estimated_demand <- sessions_estimated %>%
get_demand(dttm_seq)
comparison_demand <- tibble(
datetime = dttm_seq,
demand_real = rowSums(demand[-1]),
demand_estimated = rowSums(estimated_demand[-1])
)
comparison_demand %>%
dyplot(ylab = 'kW') %>%
dySeries('demand_real', 'Real demand', color = 'black', strokePattern = 'dashed', strokeWidth = 2) %>%
dySeries('demand_estimated', 'Estimated demand', color = 'navy', fillGraph = T)
source("~/Resourcefully Dropbox/Marc Canigueral/PROJECTS/R PACKAGES/evprof/data-raw/california_ev_sessions_profiles.R", echo=TRUE)
devtools::spell_check()
goodpractice::gp()
library(testthat)        # load testthat package
library(evprof)
library(dplyr)
library(tibble)
library(lubridate)
library(purrr)
library(ggplot2)
# Get the example `evmodel` and `sessions` included in the package
ev_model <- evprof::california_ev_model
sessions <- evprof::california_ev_sessions
temp_dir <- tempdir()
# Test exploration --------------------------------------------------------
test_that("Charging rates ratios calculation", {
expect_true(is.tibble(get_charging_rates_distribution(sessions)))
})
expect_true(is_tibble(get_charging_rates_distribution(sessions)))
# Test exploration --------------------------------------------------------
test_that("Charging rates ratios calculation", {
expect_true(is_tibble(get_charging_rates_distribution(sessions)))
})
test_that("Average daily sessions calculation", {
expect_true(is.numeric(get_daily_avg_n_sessions(sessions, 2023, 1, 7)))
})
# Exploration plots
test_that("Statistic summary of sessions' features", {
expect_true(is.tibble(
summarise_sessions(sessions, mean, vars = c("Power", "Energy", "ConnectionHours"))
))
})
# Exploration plots
test_that("Statistic summary of sessions' features", {
expect_true(is_tibble(
summarise_sessions(sessions, mean, vars = c("Power", "Energy", "ConnectionHours"))
))
})
test_that("Statistic plot of sessions' features", {
expect_true(is.ggplot(
plot_histogram_grid(sessions, vars = c("Power", "Energy", "ConnectionHours"))
))
})
test_that("Points plot", {
expect_true(is.ggplot(
plot_points(sessions, log = FALSE)
))
expect_true(is.ggplot(
plot_points(sessions, log = TRUE)
))
})
test_that("Density 2D plots", {
expect_true(is.ggplot(
plot_density_2D(sessions, by = "wday", log = FALSE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "month", log = FALSE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "year", log = FALSE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "wday", log = TRUE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "month", log = TRUE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "year", log = TRUE)
))
})
test_that("Density 3D plots", {
expect_true("plotly" %in% class(
plot_density_3D(sessions, log = FALSE)
))
expect_true("plotly" %in% class(
plot_density_3D(sessions, log = TRUE)
))
})
sessions
plot_density_3D(sessions, log = FALSE)
plot_density_3D(sessions, log = TRUE)
sessions %>% evprof:::mutate_to_log()
sessions %>% evprof:::mutate_to_log() %>% MASS::kde2d(.[["ConnectionStartDateTime"]], .[["ConnectionHours"]])
sessions %>% evprof:::mutate_to_log() %>% pull(ConnectionStartDateTime) %>% sum
sessions %>% evprof:::mutate_to_log() %>% pull(ConnectionHours) %>% sum
sessions %>% evprof:::mutate_to_log() %>% filter(ConnectionStartDateTime < 0)
sessions %>% evprof:::mutate_to_log() %>% filter(ConnectionStartDateTime < 10000)
sessions %>% evprof:::mutate_to_log() %>% filter(ConnectionStartDateTime < -10000)
sessions %>% evprof:::mutate_to_log() %>% filter(ConnectionStartDateTime < -10000) %>% pull(Session)
sessions %>% filter(Session == "6067b720f9af8b7a772391fa")
getOption("evprof.start.hour")
sessions %>% filter(Session == "6067b720f9af8b7a772391fa") %>% pull(ConnectionStartDateTime) %>% convert_time_dt_to_plot_num()
sessions %>% filter(Session == "6067b720f9af8b7a772391fa") %>% pull(ConnectionStartDateTime) %>% evprof:::convert_time_dt_to_plot_num()
log(0)
#' Modify numeric time value according to a time sequence start time
#'
#' @param time_num Numeric time value (hour-based)
#' @param start Start hour (int)
#'
convert_time_num_to_plot_num <- function(time_num, start=getOption("evprof.start.hour")) {
time_num[time_num <= start] <- time_num[time_num <= start] + 24
time_num
}
sessions %>% filter(Session == "6067b720f9af8b7a772391fa") %>% pull(ConnectionStartDateTime) %>% evprof:::convert_time_dt_to_plot_num()
sessions %>% filter(Session == "6067b720f9af8b7a772391fa") %>% pull(ConnectionStartDateTime) %>% convert_time_num_to_plot_num()
#' Convert datetime values to sorted numeric values considering a start time
#'
#' @param time_dt Datetime value
#' @param start Start hour (int)
#'
convert_time_dt_to_plot_num <- function(time_dt, start=getOption("evprof.start.hour")) {
convert_time_num_to_plot_num(convert_time_dt_to_num(time_dt), start)
}
sessions %>% filter(Session == "6067b720f9af8b7a772391fa") %>% pull(ConnectionStartDateTime) %>% convert_time_dt_to_plot_num()
#' Convert datetime value to numeric (hour-based)
#'
#' @param time_dt Datetime value
#'
#' @importFrom lubridate hour minute second
#'
convert_time_dt_to_num <- function(time_dt) {
hour(time_dt) + minute(time_dt)/60 + second(time_dt)/3600
}
sessions %>% filter(Session == "6067b720f9af8b7a772391fa") %>% pull(ConnectionStartDateTime) %>% convert_time_dt_to_plot_num()
library(testthat)        # load testthat package
# library(evprof)
devtools::load_all()
library(dplyr)
library(tibble)
library(lubridate)
library(purrr)
library(ggplot2)
# Get the example `evmodel` and `sessions` included in the package
ev_model <- evprof::california_ev_model
sessions <- evprof::california_ev_sessions
temp_dir <- tempdir()
# Test exploration --------------------------------------------------------
test_that("Charging rates ratios calculation", {
expect_true(is_tibble(get_charging_rates_distribution(sessions)))
})
test_that("Average daily sessions calculation", {
expect_true(is.numeric(get_daily_avg_n_sessions(sessions, 2023, 1, 7)))
})
# Exploration plots
test_that("Statistic summary of sessions' features", {
expect_true(is_tibble(
summarise_sessions(sessions, mean, vars = c("Power", "Energy", "ConnectionHours"))
))
})
test_that("Statistic plot of sessions' features", {
expect_true(is.ggplot(
plot_histogram_grid(sessions, vars = c("Power", "Energy", "ConnectionHours"))
))
})
test_that("Points plot", {
expect_true(is.ggplot(
plot_points(sessions, log = FALSE)
))
expect_true(is.ggplot(
plot_points(sessions, log = TRUE)
))
})
test_that("Density 2D plots", {
expect_true(is.ggplot(
plot_density_2D(sessions, by = "wday", log = FALSE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "month", log = FALSE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "year", log = FALSE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "wday", log = TRUE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "month", log = TRUE)
))
expect_true(is.ggplot(
plot_density_2D(sessions, by = "year", log = TRUE)
))
})
test_that("Density 3D plots", {
expect_true("plotly" %in% class(
plot_density_3D(sessions, log = FALSE)
))
expect_true("plotly" %in% class(
plot_density_3D(sessions, log = TRUE)
))
})
# Test preprocessing ------------------------------------------------------
# Cut outlying sessions from threshold
test_that("The outliers are removed by cutting", {
sessions2 <- cut_sessions(sessions, connection_start_min = 3, log = FALSE)
expect_true(nrow(sessions2) < nrow(sessions))
sessions2 <- cut_sessions(sessions, connection_start_max = 24, log = FALSE, start = 3)
expect_true(nrow(sessions2) < nrow(sessions))
sessions2 <- cut_sessions(sessions, connection_hours_max = 20, log = FALSE)
expect_true(nrow(sessions2) < nrow(sessions))
sessions2_log <- cut_sessions(sessions, connection_start_min = 1, log = TRUE)
expect_true(nrow(sessions2_log) < nrow(sessions))
sessions2_log <- cut_sessions(sessions, connection_hours_min = -2, log = TRUE)
expect_true(nrow(sessions2_log) < nrow(sessions))
})
# kNN plot
test_that("kNN plots", {
expect_true(is.ggplot(
plot_kNNdist(sessions, log = FALSE)
))
expect_true(is.ggplot(
plot_kNNdist(sessions, log = TRUE)
))
})
# In the outliers detection function we depend on DBSCAN package
test_that("The outliers are detected properly with automatic MinPts and eps setting", {
sessions_outliers <<- detect_outliers(sessions, noise_th = 1, log = TRUE, MinPts = 200, eps = 0.33)
sessions_outliers2 <- detect_outliers(sessions, noise_th = 1, log = FALSE, MinPts = 200, eps = 2)
expect_true(is.logical(sessions_outliers$Outlier))
expect_true(is.logical(sessions_outliers2$Outlier))
})
# Outliers plots
test_that("Outliers plots", {
expect_true(is.ggplot(
plot_outliers(sessions_outliers, log = TRUE)
))
expect_true(is.ggplot(
plot_outliers(sessions_outliers, log = FALSE)
))
})
# Remove outliers
test_that("The outliers are removed by filtering", {
sessions_outliers2 <- drop_outliers(sessions_outliers)
expect_true(nrow(sessions_outliers2) < nrow(sessions_outliers))
})
# Disconnection day division lines
test_that("Disconnection day division lines plot", {
expect_true(is.ggplot(
plot_points(sessions) %>%
plot_division_lines(n_lines = 1, division_hour = 10)
))
})
# Divisions by Disconnection day and Time-cycle
test_that("The divisions are done", {
sessions_divided <- sessions %>%
divide_by_disconnection(division_hour = 10) %>%
divide_by_timecycle()
expect_true(ncol(sessions_divided) > ncol(sessions))
})
# Test clustering ---------------------------------------------------------
# BIC plot
test_that("BIC plot is executed without errors", {
expect_no_error(
choose_k_GMM(sessions, 1:3)
)
})
# Clustering iteration
test_that("Clustering iteration file is saved correctly",  {
temp_file <- file.path(temp_dir, "iteration.pdf")
save_clustering_iterations(sessions, 2, 2, filename = temp_file)
expect_true(file.exists(temp_file))
})
# In the clustering function we depend on MCLUST package
test_that("Clusers are found correctly", {
sessions_clusters <<- cluster_sessions(sessions, k = 2, seed = 123, log = TRUE)
sessions_clusters2 <- cluster_sessions(sessions, k = 2, seed = 123, log = FALSE)
expect_equal(names(sessions_clusters), c("sessions", "models"))
expect_true("Cluster" %in% names(sessions_clusters$sessions))
expect_true(nrow(sessions_clusters$models) == 2) # Number of clusters == k
})
test_that("Clusers are plotted correctly", {
plot_clusters <- plot_bivarGMM(sessions_clusters$sessions, sessions_clusters$models, log = FALSE)
plot_clusters_log <- plot_bivarGMM(sessions_clusters$sessions, sessions_clusters$models, log = TRUE)
expect_true(is.ggplot(plot_clusters))
expect_true(is.ggplot(plot_clusters_log))
})
# Test profiling ----------------------------------------------------------
test_that("Profiles are identified through cluster definitions", {
clusters_definition <<- define_clusters(
sessions_clusters$models,
interpretations = c("Morning sessions", "Afternoon sessions"),
profile_names = c("Morning", "Afternoon")
)
sessions_profiles <<- set_profiles(list(sessions_clusters$sessions), list(clusters_definition))
expect_true(is.data.frame(sessions_profiles))
})
# Test modelling ----------------------------------------------------------
test_that("Get the connection models", {
connection_GMM <<- get_connection_models(list(sessions_clusters), list(clusters_definition))
expect_true(is.data.frame(connection_GMM))
expect_true(all.equal(c("profile", "ratio", "connection_models"), names(connection_GMM)))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(connection_GMM$connection_models[[1]])))
})
test_that("Tables and plot of connection GMM are generated without errors", {
expect_no_error(
print_connection_models_table(connection_GMM, full_width = TRUE, label = "tab:conn", caption = "connection GMM")
)
expect_true(is.ggplot(
plot_model_clusters(list(sessions_clusters), list(clusters_definition), connection_GMM)
))
})
test_that("Get and plot the energy models with `by_power = FALSE`", {
energy_GMM <<- get_energy_models(sessions_profiles, log = TRUE, by_power = FALSE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
})
test_that("Get and plot the energy models with `by_power = FALSE`", {
energy_GMM <<- get_energy_models(sessions_profiles, log = TRUE, by_power = FALSE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
})
test_that("Tables and plot of energy GMM are generated without errors", {
expect_no_error(
print_user_profile_energy_models_table(energy_GMM$energy_models[[1]], full_width = TRUE, label = "tab:en", caption = "energy GMM")
)
expect_true(is.ggplot(
plot_energy_models(energy_GMM)
))
})
test_that("Get and plot the energy models with `by_power = TRUE`", {
sessions_profiles <- sessions_profiles %>%
mutate(Power = round_to_interval(Power, 3.7)) %>%
filter(Power < 11)
sessions_profiles$Power[sessions_profiles$Power == 0] <- 3.7
# sessions_profiles %>% get_charging_rates_distribution()
energy_GMM <- get_energy_models(sessions_profiles, log = TRUE, by_power = TRUE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
energy_plot <- plot_energy_models(energy_GMM)
expect_true(is.ggplot(energy_plot))
})
test_that("Model file is saved correctly",  {
evmodel <<- get_ev_model(
names = c("Weekday", "Weekend"),
months_lst = list(1:12),
wdays_lst = list(1:5, 6:7),
connection_GMM = list(connection_GMM, connection_GMM),
energy_GMM = list(energy_GMM, energy_GMM),
connection_log = T, energy_log = T,
data_tz = "America/Los_Angeles"
)
print(evmodel)
temp_model_file <- file.path(temp_dir, "model.json")
save_ev_model(evmodel, file = temp_model_file)
expect_true(file.exists(temp_model_file))
})
test_that("Model file is read correctly",  {
temp_model_file <- file.path(temp_dir, "model.json")
evmodel <- read_ev_model(file = temp_model_file)
expect_true(class(evmodel) == "evmodel")
})
devtools::check()
library(evprof)
devtools::check()
devtools::check_rhub()
devtools::check_win_devel()
devtools::release()
devtools::check_win_devel()
library(evprof)
devtools::check_win_devel()
library(evprof)
devtools::check_win_devel()
devtools::release()
