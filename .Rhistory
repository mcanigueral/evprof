library(lubridate)
library(ggplot2)
library(dygraphs)
library(purrr)
library(tidyr)
library(dutils)
load('california_data/california_sessions_divided.RData')
load('california_data/california_GMM.RData')
load('california_data/california_sessions_profiles.RData')
load('california_data/california_sessions_models.RData')
load('california_data/california_comparison_demand.RData')
sessions <- evprof::california_ev_sessions
options(
evprof.tzone = "America/Los_Angeles",
evprof.start.hour = 3
)
plot_points(sessions, size = 0.25) %>%
plot_division_lines(n_lines = 1, division_hour = 12)
sessions_divisions <- sessions %>%
divide_by_disconnection(division_hour = 12) %>%
drop_na(Disconnection)
library(evprof)
knitr::opts_chunk$set(echo = TRUE, warning = F, message = F, error = F)
library(evprof)
library(dplyr)
library(lubridate)
library(ggplot2)
library(dygraphs)
library(purrr)
library(tidyr)
library(dutils)
load('california_data/california_sessions_divided.RData')
load('california_data/california_GMM.RData')
load('california_data/california_sessions_profiles.RData')
load('california_data/california_sessions_models.RData')
load('california_data/california_comparison_demand.RData')
sessions <- evprof::california_ev_sessions
options(
evprof.tzone = "America/Los_Angeles",
evprof.start.hour = 3
)
plot_points(sessions, size = 0.25) %>%
plot_division_lines(n_lines = 1, division_hour = 12)
sessions_divisions <- sessions %>%
divide_by_disconnection(division_hour = 12) %>%
drop_na(Disconnection)
sessions_divisions %>%
group_by(Disconnection) %>%
summarise(n = n()) %>%
mutate(pct = n/sum(n)*100) %>%
knitr::kable(digits = 2, col.names = c("Disconnection day", "Number of sessions", "Percentage of sessions (%)"))
sessions_day <- divide_by_disconnection(
california_ev_sessions,
division_hour = 10, start = 3
) %>%
filter(Disconnection == 1)
sessions_day <- divide_by_disconnection(
california_ev_sessions,
division_hour = 10, start = 3
) %>%
filter(Disconnection == 1)
sessions_day
california_ev_sessions
View(california_ev_sessions)
sessions_day %>% plot_points()
sessions_clusters <- cluster_sessions(
sessions_day, k=2, seed = 1234
)
plot_points(sessions_clusters$sessions) +
ggplot2::aes(color = Cluster)
sessions_timecycles <- divide_by_timecycle(
california_ev_sessions,
months_cycles = list(1:12),
wdays_cycles = list(1:5, 6:7)
)
# The column `Timecycle` has been added
names(sessions_timecycles)
plot_points(sessions_timecycles) +
ggplot2::facet_wrap(vars(Cluster))
plot_points(sessions_timecycles) +
ggplot2::facet_wrap(vars(Timecycle))
sessions_disconnection <- divide_by_disconnection(
california_ev_sessions, division_hour = 10
)
# The column `Disconnection` has been added
names(sessions_disconnection)
plot_points(sessions_disconnection) +
ggplot2::aes(color = Disconnection)
library(ggplot2)
plot_points(sessions_disconnection) +
facet_wrap(vars(Disconnection))
# Identify two clusters
sessions_clusters <- cluster_sessions(
sessions_day, k=2, seed = 1234
)
# Plot the clusters found
plot_bivarGMM(
sessions = sessions_clusters$sessions,
models = sessions_clusters$models,
log = TRUE, start = 3
)
# Identify two clusters
sessions_clusters <- cluster_sessions(
sessions_day, k=2, seed = 1234, log = TRUE
)
# Plot the clusters found
plot_bivarGMM(
sessions = sessions_clusters$sessions,
models = sessions_clusters$models,
log = TRUE, start = 3
)
# Define the clusters with user profile interpretations
define_clusters(
models = sessions_clusters$models,
interpretations = c(
"Connections during working hours",
"Connections during all day (high variability)"
),
profile_names = c("Workers", "Visitors"),
log = TRUE
)
tempfile()
tempdir()
tempdir("evmodel.json")
path.expand(tempdir(), "evmodel.json")
file.path(tempdir(), "evmodel.json")
file.path(tempdir(), "evmodel.json")
print.evmodel(california_ev_model)
print(california_ev_model)
# Plot all bi-variable GMM (clusters) with the colors corresponding
# to their assigned user profile
plot_model_clusters(
subsets_clustering = list(sessions_clusters),
clusters_definition = list(clusters_definitions),
profiles_ratios = connection_models[c("profile", "ratio")]
)
clusters_definitions <- define_clusters(
models = sessions_clusters$models,
interpretations = c(
"Connections during working hours",
"Connections during all day (high variability)"
),
profile_names = c("Workers", "Visitors"),
log = TRUE
)
# Plot all bi-variable GMM (clusters) with the colors corresponding
# to their assigned user profile
plot_model_clusters(
subsets_clustering = list(sessions_clusters),
clusters_definition = list(clusters_definitions),
profiles_ratios = connection_models[c("profile", "ratio")]
)
# Create a table with the connection GMM parameters
connection_models <- get_connection_models(
subsets_clustering = list(sessions_clusters),
clusters_definition = list(clusters_definitions)
)
# Plot all bi-variable GMM (clusters) with the colors corresponding
# to their assigned user profile
plot_model_clusters(
subsets_clustering = list(sessions_clusters),
clusters_definition = list(clusters_definitions),
profiles_ratios = connection_models[c("profile", "ratio")]
)
library(testthat)        # load testthat package
library(evprof)       # load our package
library(dplyr)
library(lubridate)
library(purrr)
library(ggplot2)
# Get the example `evmodel` included in the package
ev_model <- evprof::california_ev_model
sessions <- evprof::california_ev_sessions
# Test exploration --------------------------------------------------------
test_that("Charging rates ratios calculation", {
expect_true(is.data.frame(get_charging_rates_distribution(sessions)))
})
test_that("Average daily sessions calculation", {
expect_true(is.numeric(get_daily_avg_n_sessions(sessions, 2023, 1, 7)))
})
# Exploration plots
summarise_sessions(sessions, mean, vars = c("Power", "Energy", "ConnectionHours"))
plot_histogram_grid(sessions, vars = c("Power", "Energy", "ConnectionHours"))
plot_points(sessions, log = FALSE)
plot_points(sessions, log = TRUE)
plot_density_2D(sessions, by = "wday", log = FALSE)
plot_density_2D(sessions, by = "month", log = FALSE)
plot_density_2D(sessions, by = "year", log = FALSE)
plot_density_2D(sessions, by = "wday", log = TRUE)
plot_density_2D(sessions, by = "month", log = TRUE)
plot_density_2D(sessions, by = "year", log = TRUE)
plot_density_3D(sessions, log = FALSE)
plot_density_3D(sessions, log = TRUE)
# Test preprocessing ------------------------------------------------------
# Cut outlying sessions from threshold
test_that("The outliers are removed by cutting", {
sessions2_log <- cut_sessions(sessions, connection_start_max = 3, log = TRUE)
sessions2 <- cut_sessions(sessions, connection_start_max = 20, log = FALSE)
expect_true(nrow(sessions2_log) < nrow(sessions))
expect_true(nrow(sessions2) < nrow(sessions))
})
# Test preprocessing ------------------------------------------------------
# Cut outlying sessions from threshold
test_that("The outliers are removed by cutting", {
sessions2_log <- cut_sessions(sessions, connection_start_min = 1, log = TRUE)
sessions2 <- cut_sessions(sessions, connection_start_min = 3, log = FALSE)
expect_true(nrow(sessions2_log) < nrow(sessions))
expect_true(nrow(sessions2) < nrow(sessions))
})
# Test preprocessing ------------------------------------------------------
# Cut outlying sessions from threshold
test_that("The outliers are removed by cutting", {
sessions2 <- cut_sessions(sessions, connection_start_min = 3, log = FALSE)
expect_true(nrow(sessions2) < nrow(sessions))
sessions2 <- cut_sessions(sessions, connection_start_max = 24, log = FALSE, start = 3)
expect_true(nrow(sessions2) < nrow(sessions))
sessions2 <- cut_sessions(sessions, connection_hours_max = 20, log = FALSE)
expect_true(nrow(sessions2) < nrow(sessions))
sessions2_log <- cut_sessions(sessions, connection_start_min = 1, log = TRUE)
expect_true(nrow(sessions2_log) < nrow(sessions))
sessions2_log <- cut_sessions(sessions, connection_hours_min = -2, log = TRUE)
expect_true(nrow(sessions2_log) < nrow(sessions))
})
# kNN plot
plot_kNNdist(sessions, log = TRUE)
plot_kNNdist(sessions, log = FALSE)
# In the outliers detection function we depend on DBSCAN package
test_that("The outliers are detected properly with automatic MinPts and eps setting", {
sessions_outliers <<- detect_outliers(sessions, noise_th = 1, log = TRUE)
sessions_outliers2 <- detect_outliers(sessions, noise_th = 1, log = FALSE)
expect_true(is.logical(sessions_outliers$Outlier))
expect_true(is.logical(sessions_outliers2$Outlier))
})
plot_outliers(sessions_outliers, log = TRUE)
plot_outliers(sessions_outliers, log = FALSE)
test_that("The outliers are removed by filtering", {
sessions_outliers2 <- drop_outliers(sessions_outliers)
expect_true(nrow(sessions_outliers2) < nrow(sessions_outliers))
})
# Disconnection day division lines
plot_points(sessions) %>%
plot_division_lines(n_lines = 1, division_hour = 3)
# Divisions by Disconnection day and Time-cycle
test_that("The divisions are done", {
sessions_divided <- sessions %>%
divide_by_disconnection(division_hour = 3) %>%
divide_by_timecycle()
expect_true(ncol(sessions_divided) > ncol(sessions))
})
# Disconnection day division lines
plot_points(sessions) %>%
plot_division_lines(n_lines = 1, division_hour = 10)
# Divisions by Disconnection day and Time-cycle
test_that("The divisions are done", {
sessions_divided <- sessions %>%
divide_by_disconnection(division_hour = 10) %>%
divide_by_timecycle()
expect_true(ncol(sessions_divided) > ncol(sessions))
})
# Test clustering ---------------------------------------------------------
# BIC plot
choose_k_GMM(sessions, 1:3)
test_that("Clustering iteration file is saved correctly",  {
temp_file <- file.path(tempdir(), "iteration.pdf")
save_clustering_iterations(sessions, 2, 2, filename = temp_file)
expect_true(file.exists(temp_file))
})
# In the clustering function we depend on MCLUST package
test_that("Clusers are found correctly", {
sessions_clusters <<- cluster_sessions(sessions, k = 2, seed = 1234, log = TRUE)
sessions_clusters2 <- cluster_sessions(sessions, k = 2, seed = 1234, log = FALSE)
expect_equal(names(sessions_clusters), c("sessions", "models"))
expect_true("Cluster" %in% names(sessions_clusters$sessions))
expect_true(nrow(sessions_clusters$models) == 2) # Number of clusters == k
})
test_that("Clusers are plotted correctly", {
plot_clusters <- plot_bivarGMM(sessions_clusters$sessions, sessions_clusters$models, log = FALSE)
plot_clusters_log <- plot_bivarGMM(sessions_clusters$sessions, sessions_clusters$models, log = TRUE)
expect_true(is.ggplot(plot_clusters))
expect_true(is.ggplot(plot_clusters_log))
})
# Test profiling ----------------------------------------------------------
test_that("Profiles are identified through cluster definitions", {
clusters_definition <<- define_clusters(
sessions_clusters$models,
interpretations = c("Morning sessions", "Afternoon sessions"),
profile_names = c("Morning", "Afternoon")
)
sessions_profiles <<- set_profiles(list(sessions_clusters$sessions), list(clusters_definition))
expect_true(is.data.frame(sessions_profiles))
})
# Test modelling ----------------------------------------------------------
test_that("Get the connection models", {
connection_GMM <<- get_connection_models(list(sessions_clusters), list(clusters_definition))
expect_true(is.data.frame(connection_GMM))
expect_true(all.equal(c("profile", "ratio", "connection_models"), names(connection_GMM)))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(connection_GMM$connection_models[[1]])))
})
print_connection_models_table(connection_GMM, full_width = TRUE, label = "tab:conn", caption = "connection GMM")
plot_model_clusters(list(sessions_clusters), list(clusters_definition), connection_GMM)
test_that("Get the energy models with `by_power = FALSE`", {
energy_GMM <<- get_energy_models(sessions_profiles, log = TRUE, by_power = FALSE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
})
print_user_profile_energy_models_table(energy_GMM$energy_models[[1]], full_width = TRUE, label = "tab:en", caption = "energy GMM")
plot_energy_models(energy_GMM)
test_that("Get the energy models with `by_power = TRUE`", {
energy_GMM <- get_energy_models(sessions_profiles, log = TRUE, by_power = TRUE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
})
energy_GMM <- get_energy_models(sessions_profiles, log = TRUE, by_power = TRUE)
sessions_profiles
rnorm(10, 5, 5)
#' @param dbl number to round
#' @param interval rounding interval
#'
#' @export
#' @returns numeric value
#'
#' @examples
#' random_vct <- rnorm(10, 5, 5)
#' round_to_interval(random_vct, 2.5)
#'
round_to_interval <- function(dbl, interval) {
round(dbl/interval)*interval
}
random_vct <- rnorm(10, 5, 5)
round_to_interval(random_vct, 2.5)
set.seed(1)
random_vct <- rnorm(10, 5, 5)
round_to_interval(random_vct, 2.5)
sessions_profiles
sessions_profiles %>% plot_histogram("Power")
sessions_profiles %>% mutate(Power = round_to_interval(Power, 3.7)) %>% plot_histogram("Power")
sessions_profiles <- sessions_profiles %>%
mutate(Power = round_to_interval(Power, 3.7))
sessions_profiles$Power[sessions_profiles$Power == 0] <- 3.7
sessions_profiles %>% plot_histogram("Power")
sessions_profiles %>%
get_charging_rates_distribution()
sessions_profiles <- sessions_profiles %>%
mutate(Power = round_to_interval(Power, 3.7)) %>%
filter(Power < 11)
sessions_profiles$Power[sessions_profiles$Power == 0] <- 3.7
sessions_profiles %>%
get_charging_rates_distribution()
# sessions_profiles %>% get_charging_rates_distribution()
energy_GMM <- get_energy_models(sessions_profiles, log = TRUE, by_power = TRUE)
energy_plots <- plot_energy_models(energy_GMM)
energy_plots
expect_true(is.ggplot(energy_plots))
test_that("Get and plot the energy models with `by_power = FALSE`", {
energy_GMM <<- get_energy_models(sessions_profiles, log = TRUE, by_power = FALSE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
print_user_profile_energy_models_table(energy_GMM$energy_models[[1]], full_width = TRUE, label = "tab:en", caption = "energy GMM")
energy_plot <- plot_energy_models(energy_GMM)
expect_true(is.ggplot(energy_plot))
})
test_that("Get and plot the energy models with `by_power = TRUE`", {
sessions_profiles <- sessions_profiles %>%
mutate(Power = round_to_interval(Power, 3.7)) %>%
filter(Power < 11)
sessions_profiles$Power[sessions_profiles$Power == 0] <- 3.7
# sessions_profiles %>% get_charging_rates_distribution()
energy_GMM <- get_energy_models(sessions_profiles, log = TRUE, by_power = TRUE)
expect_true(is.data.frame(energy_GMM))
expect_true(all.equal(c("profile", "energy_models"), names(energy_GMM)))
expect_true(all.equal(c("charging_rate", "energy_models", "mclust"), names(energy_GMM$energy_models[[1]])))
expect_true(all.equal(c("mu", "sigma", "ratio"), names(energy_GMM$energy_models[[1]]$energy_models[[1]])))
energy_plot <- plot_energy_models(energy_GMM)
expect_true(is.ggplot(energy_plot))
})
energy_GMM
energy_models
library(dplyr)
# Select working day sessions (`Timecycle == 1`) that
# disconnect the same day (`Disconnection == 1`)
sessions_day <- california_ev_sessions %>%
divide_by_timecycle(
months_cycles = list(1:12), # Not differentiation between months
wdays_cycles = list(1:5, 6:7) # Differentiation between workdays/weekends
) %>%
divide_by_disconnection(
division_hour = 10, start = 3
) %>%
filter(
Disconnection == 1, Timecycle == 1
)
plot_points(sessions_day, start = 3)
# Identify two clusters
sessions_clusters <- cluster_sessions(
sessions_day, k=2, seed = 1234, log = TRUE
)
# Plot the clusters found
plot_bivarGMM(
sessions = sessions_clusters$sessions,
models = sessions_clusters$models,
log = TRUE, start = 3
)
# Define the clusters with user profile interpretations
clusters_definitions <- define_clusters(
models = sessions_clusters$models,
interpretations = c(
"Connections during working hours",
"Connections during all day (high variability)"
),
profile_names = c("Workers", "Visitors"),
log = TRUE
)
# Get connection GMM parameters
connection_models <- get_connection_models(
subsets_clustering = list(sessions_clusters),
clusters_definition = list(clusters_definitions)
)
# Classify each session to the corresponding user profile
sessions_profiles <- set_profiles(
sessions_clustered = list(sessions_clusters$sessions),
clusters_definition = list(clusters_definitions)
)
# Get energy GMM parameters
energy_models <- get_energy_models(sessions_profiles, log = TRUE)
ev_model <- get_ev_model(
names = c("Working days"),
months_lst = list(1:12),
wdays_lst = list(1:5),
connection_GMM = connection_models,
energy_GMM = energy_models,
connection_log = TRUE,
energy_log = TRUE,
data_tz = "America/Los_Angeles"
)
energy_GMM = energy_models
connection_GMM = connection_models
wdays_lst = list(1:5)
months_lst = list(1:12)
names = c("Working days")
connection_GMM
energy_GMM
map(
energy_GMM,
~ .x %>%
mutate(
energy_models = map(
.data$energy_models,
~ select(.x, - "mclust")
)
)
)
energy_GMM
energy_GMM %>%
mutate(
energy_models = map(
.data$energy_models,
~ select(.x, - "mclust")
)
energy_GMM
energy_GMM %>%
mutate(
energy_models = map(
.data$energy_models,
~ select(.x, - "mclust")
))
# Remove `mclust` component from energy models tibble
energy_GMM <- purrr::map(
energy_GMM,
~ .x %>%
mutate(
energy_models = purrr::map(
.data$energy_models,
~ select(.x, - "mclust")
)
)
)
energy_GMM = energy_models
energy_GMM
e = 1
install.packages(c('goodpractice', 'inteRgrate'))
devtools::spell_check()
?devtools::spell_check
goodpractice::gp()
inteRgrate::check_lintr()
?seq_len()
seq_len(c(1, 2, 3, 4, 5))
seq_len(length(c(1, 2, 3, 4, 5)))
install.packages('inteRgrate')
install.packages('inteRgrate')
usethis::use_tidy_description()
devtools::check_win_devel()
devtools::check_rhub()
rhub::check_for_cran()
devtools::check_win_devel()
pkgdown::build_site()
pkgdown::build_site()
.Last.error
pkgdown::build_reference_index()
pkgdown::build_site()
pkgdown::build_article("evprof")
pkgdown::build_article("evprof")
rlang::last_trace()
library(evprof)
pkgdown::build_article("evprof")
pkgdown::build_site()
devtools::release()
